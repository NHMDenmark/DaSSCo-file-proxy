# Deployment info
deploy-info.artifact=@project.artifactId@
deploy-info.version=@project.version@
deploy-info.build-time=@timestamp@

# Application health check and info
management.endpoint.health.show-details = always
management.endpoint.health.show-components = always
management.endpoints.web.exposure.include = health, info

management.endpoint.health.status.order = fatal,down,out-of-service,unknown,up
management.endpoint.health.status.http-mapping.down = 503
management.endpoint.health.status.http-mapping.fatal = 500
management.endpoint.health.status.http-mapping.out-of-service = 410
management.endpoint.health.status.http-mapping.unknown = 420

# The property names corresponds directly to the HTTP header names, with one additional trick:
# Allow-Origin can be a comma-separated list rather than a single origin.
cors.Access-Control-Allow-Origin=${CORS_ALLOW_ORIGIN: http://localhost:4200/}
cors.Access-Control-Allow-Methods=GET, PUT, POST, DELETE, HEAD, OPTIONS
cors.Access-Control-Allow-Headers=Authorization, Accept, Origin, Content-Type, Cache-Control, If-None-Match
cors.Access-Control-Expose-Headers=Access-Control-Allow-Origin, ETag
cors.Access-Control-Max-Age=86400

# Authorization
# Using existing environment keys for compatibility
auth.keycloak.realm=${KEYCLOAK_REALM:dassco}
auth.serverRootUrl=${KEYCLOAK_AUTH_SERVER_URL:http://localhost:8083/}
auth.clientName=${KEYCLOAK_RESOURCE:dassco-asset-service}
auth.serverUrl=${auth.serverRootUrl}realms/${auth.keycloak.realm}

spring.security.oauth2.resourceserver.jwt.jwk-set-uri=${auth.serverUrl}/protocol/openid-connect/certs

# Postgres datasource
datasource.jdbcUrl=${POSTGRES_URL:jdbc:postgresql://localhost:5432/dassco_file_proxy}
datasource.username=${POSTGRES_USER:dassco_file_proxy}
datasource.password=${POSTGRES_PASSWORD:dassco_file_proxy}
datasource.connectionTimeout=${POSTGRES_CONNECTION_TIMEOUT:30000}
datasource.idleTimeout=${POSTGRES_IDLE_TIMEOUT:600000}
datasource.maxLifetime=${POSTGRES_MAX_LIFETIME:1800000}
datasource.minimumIdle=${POSTGRES_MINIMUM_IDLE:2}
datasource.maximumPoolSize=${POSTGRES_MAXIMUM_POOL_SIZE:5}

# Keycloak admin config
keycloak.admin.keycloakUrl=${auth.serverRootUrl}
keycloak.admin.climbalongRealm=${auth.keycloak.realm}
keycloak.admin.adminRealm=${KEYCLOAK_ADMIN_REALM:dassco}
keycloak.admin.clientId=${KEYCLOAK_ADMIN_CLIENT_ID:dassco-file-proxy}
keycloak.admin.clientSecret=${KEYCLOAK_ADMIN_CLIENT_SECRET:ZxbM7080Q1T5Xue5wf64XtfaLquhKt6I}
keycloak.admin.username=${KEYCLOAK_ADMIN_USERNAME:admin}
keycloak.admin.password=${KEYCLOAK_ADMIN_PASSWORD:admin}

# Asset service properties
asset-service.rootUrl=${ASSET_SERVICE_ROOT_URL:http://localhost:8084}

# Liquibase
logging.level.liquibase=INFO
spring.liquibase.change-log=classpath:/liquibase/changelog-master.xml
spring.liquibase.contexts=default
spring.liquibase.enabled=true

# Erda
erda.server=${ERDA_SERVER:io.erda.dk}
erda.port=${ERDA_PORT:21}
erda.user=${ERDA_USER:}
erda.password=${ERDA_PASSWORD:}

sftp.config.host=${SFTP_HOST:io.erda.dk}
sftp.config.port=${SFTP_PORT:22}
sftp.config.username=${SFTP_USERNAME:christoffer@northtech.dk}
sftp.config.privateKey=${SFTP_PRIVATE_KEY_LOCATION:./private_key}
sftp.config.passphrase=${SFTP_PRIVATE_KEY_PASSPHRASE:testtest}
sftp.config.localFolder=${SFTP_LOCAL_FOLDER:target/DaSSCoStorage/}
sftp.config.remoteFolder=${SFTP_REMOTE_FOLDER:/DaSSCoStorage/}

spring.config.import=optional:file:./application-local.properties

logging.level.org.springframework=INFO
logging.pattern.console= %d{yyyy-MM-dd HH:mm:ss} - %msg%n
logging.pattern.file= %d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%
server.port=8080

docker.dockerHost=${DOCKER_HOST:unix:///var/run/docker.sock}
docker.mountFolder=${DOCKER_FOLDER:/Users/christofferhansen/dev/baseImage/jfileserver/test_folder/}
docker.portRangeStart=${PORT_RANGE_START:6060}
docker.portRangeEnd=${PORT_RANGE_END:6070}
